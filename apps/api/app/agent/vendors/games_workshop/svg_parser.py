# standard
import re
from dataclasses import dataclass, field
from parsel import Selector, SelectorList
from typing import Optional
from urllib.error import HTTPError, URLError
from urllib.request import Request, urlopen

# local
from app.agent.color import Color
from app.agent.models import IsccNbsData, ProductSwatch
from app.core.enums import Overlay
from app.core.utils.collection.path import isurl
from app.core.utils.collection.string import capitalize

from ._algolia import get_algolia_headers

"""
The functions in this file attempt the following:

1. Takes SVG content as input and returns a list of RGB tuples
2. Uses helper functions to:
   - Extract color values from both attributes and style definitions
   - Extract color values from any `stop` elements in any found gradient
3. Takes found color values and generates Color instances to handle:
   - Converting hex colors to RGB tuples
   - Converting CSS RGB strings to (R, G, B) tuples
   - Extract color values from both attributes and style definitions
4. First checks the `rect` element for direct color values
5. If the rect has a defined `fill` with a gradient reference, processes the gradient stops
6. If the rect has no defined `fill`, it checks for a class, if found, it searches for a `style`
   block where the class is defined. If the class' declaration block defines a fill with a
   gradient reference, it finds the gradient and processes any `stop` elements therein.
6. If only two colors are found in a gradient, calculates a middle color
7. Falls back to checking the `g` element if no colors are found
8. Raises an exception if no valid colors are found

The initial code was generated by Claude Sonnet 3.5 and based that code upon a prompt that included several
sample SVGs from the Citadel paints product display page on Games Workshops' warhammer.com retail site. The
samples included SVGs whose code, despite all displaying simlar content, varied wildly in how they were
composed. The common elements were:

- They display the shape of a paint pot via clip-path
- They contain a gradient element, which could be either a `radialGradient`, a `linearGradient`, or both
- Contain a single `rect` element wrapped by a `g` element
- Organized their gradient elements and any `style` blocks within a `def` element

The cases of difference between the sample SVGs were:

- One ("Hobgrot Hide") where:
   - Hex color assigned as the `rect` element's `fill` value
   - Gradient is present but has no stop colors defined
- One ("Balthasar Gold") where:
   - Gradient is a `radialGradient`
   - Gradient is set in a `defs` block below the `g` element
   - Gradient contains 3 `stop` elements
   - Stop colors are defined in `style` attributes
   - The `g` element has a `fill` attribute with a hex color value
- One ("Coelia Greenshade") where:
   - Gradient is set in a `defs` block below the `g` element
   - Gradient is vertical instead of horizontal
   - Color stops set using `stop-color` attribute
- One ("Briar Queen Chill") where:
   - The `rect` element does not have an assigned `fill` value
   - The `rect` element has a class defined in a style block where a gradient is referenced
   - Gradient is set in a `defs` block above the `g` element
   - Gradient has 2 `stop` elements
   - Color stops set using `stop-color` attribute
- One ("Blood for the Blood God") where:
   - Two gradients are present, one radial, one linear, only radial is referenced anywhere
   - Radial gradient has `stop-opacity` values set to less than 1
   - There is a `path` element with a `fill` attribute referencing the radial gradient
   - The `rect` element has a hex value assigned to its `fill` attribute, the only assignable color value

Returns a list of Color objects so that color values can be converted to other color spaces later on.
"""

def fetch_citadel_svg(imgurl: str):
    """
    Open the URL for an individual SVG on the GW site and grab the markup.

    Args:
    -----
        imgurl - The URL for the SVG
    """
    try:
        """
        Fetch the SVG for a given product. The URL is coming from the product data
        coming from the Games Workshop site.
        """
        # We need the configured Algolia headers to make the request for an image
        image_headers = get_algolia_headers('en-US')
        req = Request(imgurl, headers=image_headers)
        page = urlopen(req).read()
        html = page.decode('utf-8')
        return html
    except HTTPError as herr:
        print(f'HTTP-related error when fetching SVG from Games Workshop - {herr}')
        raise herr
    except URLError as urlerr:
        print(f'Could not fetch SVG from Games Workshop due to a URL-related error. Verify the URL is correct - {urlerr}')
        raise urlerr
    except Exception as exc:
        print(f'Exception while requesting SVG from Games Workshop - {exc}')
        raise exc

def to_swatch_color(colors: list[Color], overlay: Overlay | None):
    """
    Convert a list of Color instances to a list of RGB tuples
    """
    start, base, end = colors
    return ProductSwatch({
        'hex_color': base.to_hex(),
        'rgb_color': base.rgb,
        'oklch_color': base.to_oklch(),
        'gradient_start': start.to_oklch(),
        'gradient_end': end.to_oklch(),
        'overlay': overlay,
    })

DEFAULT_COLOR_STOPS = ['#000000' for i in range(3)]

@dataclass
class SVGProductMeta(IsccNbsData):
    """
    Represents the data related to the product resolved from parsing its representative
    SVG file.

    Properties:
    -----------
        application_method - Any unique technique with how the paint is designed to be applied
        colors - The color values extracted from the SVG
        opacity - How opaque the paint is
        overlay - Some product types will benefit from applying an overlay to the color
            swatch to convey properties other that hue, tint, and shadow.
        tags - Secondary classification labels that may be useful in search
        viscosity - How thick the paint is and how it behaves
    """
    # colors: list[Color] = field(defaulT=DEFAULT_COLOR_STOPS)
    swatch: ProductSwatch
    tags: list[str] = field(default_factory=list)
    # overlay: Overlay | None = None

    # def _output(self):
    #     tags = list(set(self.tags))
    #     start, base, end = self.colors
    #     swatch = ProductSwatch({
    #         'hex_color': base.to_hex(),
    #         'rgb_color': base.rgb,
    #         'oklch_color': base.to_oklch(),
    #         'gradient_start': start.to_oklch(),
    #         'gradient_end': end.to_oklch(),
    #         'overlay': self.overlay,
    #     })
    #     iscc_data = base.get_iscc_nbs_data()

    #     return {
    #         'swatch': swatch,
    #         'tags': tags,
    #         'color_range': iscc_data.get('color_range', None),
    #         'analogous': iscc_data.get('analogous', None),
    #         'iscc_nbs_category': iscc_data.get('iscc_nbs_category', None),
    #     }

    # def serialize(self):
    #     return serialize(self._output())
    
    # def to_json(self):
    #     return to_json(self._output())


def _get_attr_value(selector: Selector, attr: str, default: Optional[str] = None) -> str:
    """
    Helper function to extract attribute possibly containing color value from a selected element
    """
    value = selector.attrib.get(attr, default)
    if not value and 'style' in selector.attrib:
        style = selector.attrib['style']
        found = re.search(fr'{attr}:\s*([^;]+)', style)
        if found:
            value = found.group(1)
    return value.strip() if value else default

def _set_colors_from_stops(stops: list[Selector]):
    """
    Helper function to iterate over a gradient element's `stop` children, extract their
    `color-stop` values, convert them into Color instances and set them in a list that
    should contain 3 items.
    """
    empty_colors_list: list[Color] = []
    colors: list[Color] = []

    for stop in stops:
        color_value = _get_attr_value(stop, 'stop-color')
        opacity = _get_attr_value(stop, 'stop-opacity')
        if color_value:
            if color_value == 'white' or (opacity and float(opacity) < 1.0):
                # Exit because the parent gradient is used as an overlay
                return empty_colors_list
            colors.append(Color(color_value))
    
    # If we only have two colors, calculate middle color
    if len(colors) == 2:
        first, last = colors
        avg_color = Color(first.mean(last))
        colors.insert(1, avg_color)

    if len(colors):
        colors.sort(key=lambda color: color.lightness, reverse=True)

    return colors


def _create_color_details(
    color: Optional[str | list[Color]] = None,
    gradient_id: Optional[str] = None,
    el_type: Optional[str] = None,
    ref_id: Optional[str] = None,
):
    colors: list[Color] = []
    if color:
        colors = [Color(color) for i in range(3)] if isinstance(color, str) else color
    return {
        'colors': colors,
        'gradient_id': gradient_id,
        'type': el_type,
        'ref_id': ref_id
    }

    
def _get_gradient_color_details(selector: Selector, gradient_ref_id: Optional[str] = None) -> list[Selector]:
    # Found gradient element
    gradient_el: Optional[str] = None
    # ID of found gradient
    gradient_id: Optional[str] = None
    
    # ID of a gradient referencing another gradient via the `xlink:href` attribute
    # ex: "/app/resources/catalog/product/920x950/99189960043_Contrast_Ironjawz_Yellow.svg"
    ref_id: Optional[str] = None

    # Color values wrapped in `Color` instances from when stop-color values are found
    colors: list[Color] = []
    gradient: Optional[Selector] = None

    # Check for both linear and radial gradients
    for element in ['radialgradient', 'lineargradient']:
        gradients = selector.css(element)
        if gradients is None:
            return
        for gradient_sel in gradients:
            xlink = gradient_sel.attrib.get('xlink:href', None)
            if xlink:
                ref_id = gradient_sel.attrib.get('id')
            stops: Optional[SelectorList] = gradient_sel.css('stop')
            if stops is None:
                continue
            stop_colors = _set_colors_from_stops(stops)
            if len(stop_colors):
                colors = stop_colors
                gradient = gradient_sel
                gradient_id = gradient.attrib.get('id')
                gradient_el = element

    if gradient:
        return _create_color_details(colors, gradient_id=gradient_id, el_type=gradient_el, ref_id=ref_id)
    return None


def _style_block_w_url_fill(style_content: str, cls: str, testid: Optional[str] = None):
    found = re.search(r'\.' + cls + r'.+?\bfill\b:\s?url\(#(.+?)\)', style_content, re.DOTALL)
    return _sanitize_gradient_id(found.group(1)) if found else None

def _style_block_w_hex_fill(style_content: str, cls: str):
    found = re.search(r'\.' + cls + r'.+?\bfill\b:\s?(#.+?);', style_content, re.DOTALL)
    return found.group(1).strip() if found else None

def _style_block_w_rgb_fill(style_content: str, cls: str):
    found = re.search(r'\.' + cls + r'.+?\bfill\b:\s?(rgb\(.+?\))', style_content)
    return found.group(1).strip() if found else None

def _from_style_block(selector: Selector, cls: str):
    style_content = selector.xpath(f'//style[contains(.,".{cls}")]/text()').get()

    if style_content is None:
        return None

    value = _style_block_w_url_fill(style_content, cls)
    if value is None:
        value = _style_block_w_hex_fill(style_content, cls)
    if value is None:
        value = _style_block_w_rgb_fill(style_content, cls)
    return value


def _sanitize_gradient_id(gradient_id: str):
    # NOTE: The gradients in the GW SVGs have IDs containing "#" symbols, so we need
    # to escape the ID or our query will fail for not being a valid selector.
    return re.escape(gradient_id.strip()) if '#' in gradient_id else gradient_id.strip()


def _resolve_color_details_from_element(selector: Selector, el: str, testid: Optional[str] = None) -> str:
    """
    Helper function to extract attribute possibly containing color value from a selected element
    """
    element = selector.css(el)
    if element is None:
        return None

    # attributes
    fill = element.attrib.get('fill', '')
    cls = element.attrib.get('class', '')

    # selectors
    style = selector.css('style')

    if len(fill):
        if fill.startswith('url(#'):
            found = re.search(r'url\(#(.+?)\)', fill)
            gradient_id = _sanitize_gradient_id(found.group(1)) if found else None
            if gradient_id:
                color_details = _get_gradient_color_details(selector, gradient_id)
                if color_details and (gradient_id == color_details['ref_id'] or gradient_id == color_details['gradient_id']):
                    return color_details
        else:
            color_details = _create_color_details(fill.strip(), el_type=el)
            if color_details:
                return color_details
            
    if len(cls) and style:
        style_content = selector.xpath(f'//style[contains(.,".{cls}")]/text()').get()
        gradient_id = _style_block_w_url_fill(style_content, cls, testid=testid)
        if gradient_id:
            color_details = _get_gradient_color_details(selector, gradient_id)
            if color_details and (gradient_id == color_details['ref_id'] or gradient_id == color_details['gradient_id']):
                return color_details
        else:
            fill = _style_block_w_hex_fill(style_content, cls)
            if fill is None:
                fill = _style_block_w_rgb_fill(style_content, cls)
            if fill:
                color_details = _create_color_details(color=fill.strip(), el_type=el)
                return color_details

    return None


def _get_product_data_from_svg(selector: Selector, product_type: Optional[str] = None):
    """
    Resolve and extract category-related data from reading the SVG's structure. Most
    paint types produced by GW have a unique way of "decorating" the paint pot shape
    used for displaying the paint color. More about these different structures is
    documented in a README.md.
    """
    if not product_type:
        svg_id = selector.xpath('//svg/@id').get()
        if svg_id:
            found = re.search('[0-9]_([a-z]+)', svg_id)
            if found:
                product_type = capitalize(found.group(1))

    if product_type is None:
        raise ValueError('Cannot extract product type from SVG ID')

    # Is the product a metallic paint? Metallic paints are distinguished in the SVG with
    # a radial gradient in the `defs` at the end of the file and THREE `stop` elements.
    radial_stops = selector.css('radialgradient stop').getall()
    is_metallic = len(radial_stops) == 3

    # Is the product a type of paint medium or varnish
    is_medium = product_type == 'Technical' and selector.css('rect').get() is None

    # product_meta = SVGProductMeta()
    tags: list[str] = []
    overlay: Overlay | None = None

    if is_metallic:
        overlay = Overlay.chrome

    match product_type:
        case 'Spray':
            tags.append('Flamable')
            # product_meta.application_method = ApplicationMethod.Spray
            return { 'tags': tags, 'overlay': overlay }
        case 'Technical':
            if is_medium:
                tags.append('Medium')
                return { 'tags': tags, 'overlay': overlay }

            texture_group = selector.css('g > g > g > path').getall()
            path_count = len(texture_group)

            if path_count:
                tags.append('Terrain Effect')
                pathcount = len(texture_group)
                if pathcount == 9:
                    overlay = Overlay.grunge
                if pathcount == 13:
                    overlay = Overlay.liquid
                if pathcount == 19:
                    overlay = Overlay.crackle

                return { 'tags': tags, 'overlay': overlay }

            tags.append('Special Effect')
            overlay_stop = selector.css('radialgradient stop')
            overlay_stop_color = _get_attr_value(overlay_stop, 'stop-color')
            if overlay_stop_color == 'white':
                """
                Paints for some special effects have a semi-transparent radial gradient overlay
                indicating a glossy finish.
                """
                tags.append('Gloss Finish')
                overlay = 'glossy'
            return { 'tags': tags, 'overlay': overlay }
        case _:
            return { 'tags': tags, 'overlay': overlay }

unprocessable_cache = []


def extract_colors_from_svg(
    svg_content: str,
    product_type: Optional[str],
    testid: Optional[str] = None
) -> SVGProductMeta:
    """
    Extract color values from an SVG file.

    ARGS:
    -----
        svg_content
            Can be either XML markup (for single-use or testing) or a URL to an SVG image file.
            
        product_type:
            [Optional] The assigned product type category given by the vendor. This aides with
            figuring out the possible structure pattern of the SVG, but also helps assign
            product characteristics that come along with that type.
            
        testid:
            Just used during testing for tracing any possible errors

    RETURNS:
    --------
        SVGProductMeta

    DESCRIPTION:
    ------------
    
    Due to the many possible variations in which the SVGs are constructed by GW, we have to
    verify in a lot of ways that we are getting the actual color values intended to represent
    the product. Some of the most difficult files to parse are the ones getting categorized
    under the product type category of "Technical", as that encompasses:
    
    - Special effects paints
    - Terrain effect paints (which are thicker and often have particles)
    - Mediums (varnishes and mixing mediums)

    The SVGs for mediums are far different from the others and are very difficult to predict
    in construction.

    So, we're going to iterate across the SVG markup and look for the following elements and
    attributes in order of most common:

    1. A `RECT` element, wrapped in a `G`, with:
        a. A `FILL` attribute with a `url()` value containing a reference to a GRADIENT element
           (can be either linear or radial, with Metallics always being radial)
        b. A `FILL` attribute with a HEX color value
        c. A `CLASS` attribute whose style definition is contained in a `DEFS` element that
           is usually right above the `G` element

    2. The `G` element wrapping the `RECT` can be assigned the base color value representing
       the product, usually assigned as a HEX color value.

    3. A `PATH` element (ONLY) with:
        a. A `FILL` attribute with a `url()` value containing a reference to a GRADIENT element
           (can be either linear or radial)
        b. A `FILL` attribute with a HEX color value
        c. A `CLASS` attribute whose style definition is contained in a `DEFS` element that
           is usually right above the `G` element (NOTE: there are cases where the PATH is
           assigned a class that has no definition anywhere in the markup)

    4. IF ALL ELSE FAILS, search for any gradient element with valid STOP elements as children
       and whose values are valid colors.

    5. As a fallback so we don't just throw an error, crashing our entire parsing queue, assign
       color values of HEX white ('#ffffff').
    """    
    # Will be assigned THREE color values based on what's parsed from the SVG
    colors = []
    
    content = svg_content
    if isurl(svg_content):
        content = fetch_citadel_svg(svg_content)
    if content is None:
        raise ValueError('SVG Content was empty.')

    selector = Selector(text=content)
    elements = ['rect', 'g', 'path']
    color_details = None
    
    for element in elements:
        color_details = _resolve_color_details_from_element(selector, element, testid)
        if color_details:
            break

    if color_details is None:
        color_details = _get_gradient_color_details(selector)

    if color_details is None:
        print(f'No valid colors found in SVG for product "{testid}"')
        unprocessable_cache.append(testid)
        color_details = _create_color_details('#ffffff')

    colors = color_details['colors']

    if testid:
        print(testid, [color.rgb for color in colors])

    tags, overlay = _get_product_data_from_svg(selector, product_type)
    # {
    #         'swatch': swatch,
    #         'tags': tags,
    #         'color_range': iscc_data.get('color_range', None),
    #         'analogous': iscc_data.get('analogous', None),
    #         'iscc_nbs_category': iscc_data.get('iscc_nbs_category', None),
    #     }
    iscc_data = colors[1].get_iscc_nbs_data()
    product_meta = SVGProductMeta(swatch=to_swatch_color(colors, overlay=overlay, tags=tags, **iscc_data))
    # if product_meta:
    #     product_meta.colors = colors

    return product_meta

# extract_colors_from_svg(balthasar_gold, testid='balthasar_gold')
# extract_colors_from_svg(hobgrot_hide, testid='hobgrot_hide')
# extract_colors_from_svg(coelia_greenshade, testid='coelia_greenshade')
# extract_colors_from_svg(blood_for_the_blood_god, testid='blood_for_the_blood_god')
# extract_colors_from_svg(briar_queen_chill, testid='briar_queen_chill')
